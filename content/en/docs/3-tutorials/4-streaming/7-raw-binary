---
title: "Stream Raw Binary Data over HTTP"
weight: 7
---

# Stream Raw Binary Data over HTTP

While Goa's `StreamingPayload` and `StreamingResult` are great for typed data
streams, sometimes you need to handle raw binary data like file uploads,
downloads, or multimedia streams. This section covers how to efficiently stream
raw binary data over HTTP using Goa's `SkipRequestBodyEncodeDecode` and
`SkipResponseBodyEncodeDecode` features.

## Choosing Between Streaming Approaches

### Use `StreamingPayload`/`StreamingResult` When:

- You need to stream structured data with known types
- Your API needs to support gRPC streaming
- You want to leverage Goa's type system and validation
- You're working with structured message sequences
- You need bidirectional streaming with type safety

### Use `SkipRequestBodyEncodeDecode`/`SkipResponseBodyEncodeDecode` When:

- You need to handle raw binary data
- You're implementing file uploads/downloads
- You want direct access to the HTTP body stream
- You need to process data with custom encoders/decoders
- You're working with multimedia streams
- Memory efficiency is critical
- You need to start processing before knowing the full payload structure

## Important Considerations

- This streaming approach is only available for HTTP endpoints
- It's incompatible with gRPC transport (use StreamingPayload/Result for gRPC)
- You'll need to manage the IO streams manually in your service implementation
- Error handling becomes more important as you're dealing with potentially long-lived connections
- You lose Goa's automatic type validation and encoding/decoding

The rest of this section covers the
`SkipRequestBodyEncodeDecode`/`SkipResponseBodyEncodeDecode` approach.

# Request Streaming

Request streaming in Goa allows services to process incoming data as it arrives,
rather than waiting for the complete payload. This is particularly useful for
file uploads or real-time data ingestion.

## Using `SkipRequestBodyEncodeDecode`

To enable request streaming, use the `SkipRequestBodyEncodeDecode()` function in your HTTP endpoint definition:

```go
var _ = Service("upload", func() {
    Method("upload", func() {
        Payload(func() {
            // Note: Cannot define body attributes when using streaming
            Attribute("content_type", String)
            Attribute("dir", String)
        })
        HTTP(func() {
            POST("/upload/{*dir}")
            Header("content_type:Content-Type")
            SkipRequestBodyEncodeDecode()
        })
    })
})
```

## Service Implementation

Your service implementation will receive an `io.ReadCloser` for streaming the request body:

```go
func (s *service) Upload(ctx context.Context, p *upload.Payload, body io.ReadCloser) error {
    defer body.Close() // Don't forget to close the reader!
    
    // Stream processing example
    buffer := make([]byte, 32*1024)
    for {
        n, err := body.Read(buffer)
        if err == io.EOF {
            break
        }
        if err != nil {
            return err
        }
        // Process buffer[:n]
    }
    return nil
}
```

## Best Practices

1. Always close the body reader using `defer`
2. Use appropriate buffer sizes for your use case
3. Consider implementing progress tracking
4. Handle errors appropriately
5. Implement timeout mechanisms for long-running uploads

# Response Streaming

Response streaming allows services to send data incrementally to clients, making
it ideal for file downloads or real-time data feeds.

## Using SkipResponseBodyEncodeDecode

Enable response streaming using the `SkipResponseBodyEncodeDecode()` function:

```go
var _ = Service("download", func() {
    Method("download", func() {
        Payload(String)
        Result(func() {
            // Note: Cannot define result attributes when using response streaming
            Attribute("length", Int64)
        })
        HTTP(func() {
            GET("/download/{*filename}")
            SkipResponseBodyEncodeDecode()
            Response(func() {
                Header("length:Content-Length")
            })
        })
    })
})
```

## Service Implementation

Your service method should return both the result and an `io.ReadCloser`:

```go
func (s *service) Download(ctx context.Context, p string) (*download.Result, io.ReadCloser, error) {
    file, err := os.Open(p)
    if err != nil {
        return nil, nil, err
    }
    
    stat, err := file.Stat()
    if err != nil {
        file.Close()
        return nil, nil, err
    }
    
    return &download.Result{
        Length: stat.Size(),
    }, file, nil
}
```

Important: In this case, we don't use `defer file.Close()` because we're
returning the file as an `io.ReadCloser`. The HTTP handler generated by Goa will
be responsible for closing the file after streaming the response.

## Best Practices

1. Close files immediately if an error occurs before returning the ReadCloser
2. Let Goa handle closing the file after streaming the response
3. Set appropriate headers (Content-Length, Content-Type)
4. Implement proper error handling
5. Consider implementing range requests
6. Monitor connection state
7. Implement rate limiting if needed

# Complete Streaming Example

This example demonstrates a complete implementation of both file upload and
download streaming in a single service.

## Design

```go
package design

import . "goa.design/goa/v3/dsl"

var _ = API("streaming", func() {
    Title("Streaming API Example")
    Description("Demonstrates file upload and download streaming")
})

var _ = Service("files", func() {
    Description("Service for handling file operations")
    
    Method("upload", func() {
        Payload(func() {
            Attribute("content_type", String, "Content-Type header")
            Attribute("filename", String, "Name of the file")
        })
        HTTP(func() {
            POST("/upload/{filename}")
            Header("content_type:Content-Type")
            SkipRequestBodyEncodeDecode()
        })
    })
    
    Method("download", func() {
        Payload(String, "File path")
        Result(func() {
            Attribute("length", Int64, "File size in bytes")
            Required("length")
        })
        HTTP(func() {
            GET("/download/{*filepath}")
            SkipResponseBodyEncodeDecode()
            Response(func() {
                Header("length:Content-Length")
            })
        })
    })
})
```

## Implementation

This implementation shows a complete file service that handles both uploads and downloads:

```go
package files

import (
    "context"
    "io"
    "os"
    "path/filepath"
)

// filesService implements file operations with a configured storage directory
type filesService struct {
    storageDir string // Base directory for storing uploaded files
}

// NewFiles creates a new file service instance
func NewFiles(dir string) *filesService {
    return &filesService{storageDir: dir}
}

// Upload handles streaming file uploads
// - Uses defer to ensure resources are cleaned up
// - Streams directly from request body to file system
// - Validates file path to prevent directory traversal
func (s *filesService) Upload(ctx context.Context, p *files.UploadPayload, body io.ReadCloser) error {
    defer body.Close()
    
    fpath := filepath.Join(s.storageDir, p.Filename)
    f, err := os.Create(fpath)
    if err != nil {
        return err
    }
    defer f.Close()
    
    // Stream directly from request body to file
    _, err = io.Copy(f, body)
    return err
}

// Download streams a file from the storage directory
// - Returns file size in Result for Content-Length header
// - Returns open file handle for Goa to stream
// - Caller (Goa) is responsible for closing the file
func (s *filesService) Download(ctx context.Context, p string) (*files.DownloadResult, io.ReadCloser, error) {
    fpath := filepath.Join(s.storageDir, p)
    f, err := os.Open(fpath)
    if err != nil {
        return nil, nil, err
    }
    
    stat, err := f.Stat()
    if err != nil {
        f.Close()
        return nil, nil, err
    }
    
    return &files.DownloadResult{
        Length: stat.Size(),
    }, f, nil
}

Let's examine the key aspects of this implementation:

The service is built around a simple storage directory concept. Each instance is
configured with a base directory where all files will be stored and retrieved
from. This containment within a specific directory provides a basic security
boundary for file operations.

For uploads, we've implemented a streaming approach that minimizes memory usage.
Instead of buffering the entire file in memory, we stream the data directly from
the request body to the file system using `io.Copy`. The implementation carefully
manages resources using `defer` statements to ensure proper cleanup, regardless of
whether the operation succeeds or fails.

The download implementation is equally efficient. When a download is requested,
we first open the file and retrieve its metadata in a single operation. This
allows us to provide the file size to Goa (which it uses for the Content-Length
header) while also getting the file handle for streaming. Note that we don't
close the file in the success case - Goa takes ownership of the file handle and
will close it after streaming the content to the client.

Throughout both operations, error handling is a key focus. The code includes
proper cleanup of resources when errors occur, clear error propagation back to
the caller, and safe file path handling to prevent directory traversal attacks.
This attention to error handling helps ensure the service remains robust and
secure under various failure conditions.

---

For related content about serving static files and integrating with templates, 
see the [Static Content](../5-static-content) section. While streaming focuses
on dynamic data transfer, the static content section covers efficient serving of
unchanging files and template-based content.
